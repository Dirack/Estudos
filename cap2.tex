\chapter{OTIMIZAÇÃO GLOBAL COM SIMULATED ANNEALING}
\label{cap2}


O algoritmo Simulated Annealing é baseado na teoria física da formação de cristais
através do resfriamento lento (Annealing) destes cristais, a partir do seu ponto de fusão.
O objetivo é minimizar a função objeto $f(p)$ a patir de perturbações aleatórias do vetor de parâmetros $p$,
para uma nova posição $p'$. O valor $p'$ é avaliado a partir do seguinte critério de aceitação:

\begin{equation}
\label{eq:2.8}
 \Delta f=f(p')-f(p) < 0
\end{equation}

O algoritmo inicia através da escolha de um valor inicial de temperatura, $T=T_0$, para esse valor inicial há
a escolha aleatória do vetor de parâmetros $p_i=(p_1,p_2,p_3,...,p_n)$. O vetor de parâmetros é perturbado 
de sua posição inicial a uma nova posição $p'_i$. Calcula-se o valor da função objeto, $f(p)$ e $f(p')$. Se $f(p')$ é
menor que $f(p)$ significa que o valor da função objeto é menor para o vetor $p'_i$
e a função objeto está convergindo para um mínimo. $p'_i$ é adotado como o
novo vetor de parâmetros, repete-se o processo até que se atinja o mínimo Global.

Se a Equação \ref{eq:2.8} é verdadeira o valor de $p'$ é aceito como o meu novo vetor de parâmetros $p$ e o processo
é reiniciado: Perturba-se $p$ para uma nova posição $p'$, e é avaliado se a Equação \ref{eq:2.8} permanece valida. 
Ou seja, a cada nova
iteração a função objeto deverá possuir um valor menor, até que atinja o seu valor mínimo.

A perturbação do vetor $p_i$ é realizada por meio da seguinte Equação:

\begin{equation}
\label{eq:2.9}
 p'_i=p_i+(2\lambda-1)v_i
\end{equation}

Todavia, a função $f(p)$ pode não convergir para o mínimo global, de modo a se manter presa
em um mínimo local. Para tanto, o algoritmo SA permite deslocamentos ascendentes no valor de $f(p)$ a partir de um critério
probabilístico (Critério de Metrópolis): Se $f(p')$ for maior que $f(p)$, a Equação \ref{eq:2.8} não será válida, então
a nova posição $p'$ não será aceita de imediato, devendo passar por um novo teste.

Calcula-se um número $P$, dado por:

\begin{equation}
\label{eq:2.10}
 P=exp(\frac{-\Delta f}{T})
\end{equation}

Se $P$ for maior do que $u$, um número aleatório entre 0 e 1, $p'_i$ será aceito, senão $p'_i$ é
descartado e o algoritmo é reiniciado com uma nova perturbação ao vetor $p$, a partir da Equação
\ref{eq:2.9}.
Valores baixos de $T$ e altos $\Delta f$ diminuem a probabilidade de que $p'_i$ seja aceito.

\section{Very Fast Simulated Annealing (VFSA)}
\label{sec:2.1}
O algoritmo Very
Fast Simulated Annealing (VFSA) surgiu com o objetivo de melhorar o desempenho do algoritmo Simulated Annealing (SA). 
Este algoritmo, também chamado de \textit{Boltzmann Annealing} (BA).
introduz varias modificações ao
algoritmo padrão SA \cite{ingber}.

No algoritmo VFSA a perturbação de cada elemento $\alpha_{k,i}$ na dimensão $i$ , é realizada
segundo a relação \cite{klaus}:

\begin{equation}
\label{eq:2.11}
 \alpha_{k+1,i}=\alpha_{k,i}+y_i(B_i-A_i)
\end{equation}

Onde $\alpha_{k+1,i}$ é um novo parâmetro obtido a partir do parâmetro $\alpha_{k,i}$ da iteração anterior.
O novo parâmetro é restrito a janela:

\begin{equation}
\label{eq:2.12}
  \alpha_{k+1,i},\alpha_{k,i}\in[A_i,B_i]
\end{equation}

Ou seja, $A_i$ e $B_i$ delimitam o espaço de busca dos parâmetros através da otimização global. 
$u_i$ e $y_i$ são números aleatórios distribuídos da seguinte forma:

\begin{equation}
\label{eq:2.13}
  y_i\in[-1,1]
\end{equation}

\begin{equation}
\label{eq:2.14}
  u_i\in[0,1]
\end{equation}

O cálculo de $y_i$ é dado por:

\begin{equation}
\label{eq:2.15}
  y_i=sgn(u_i-1/2)T_i[(1+1/T_i)^{2u_i-1}-1]
\end{equation}

Onde $sgn()$ é a função sinal, definida da seguinte forma:

%\begin{equation}
$$sgn(t)=1, t > 0$$

$$sgn(t)=-1 t < 0$$
%\end{equation}


O mínimo global pode ser obtido usando a sequência de refriamento $T_i$, definida da seguinte forma \cite{ingber}:

\begin{equation}
\label{eq:2.16}
 T_i(k)=T_{0i}exp(-C_ik^{1/n})
\end{equation}

Onde o parâmetro $T_{0i}$ é a temperatura inicial, e $C_i$ é um parâmetro livre para controle do decaimento e ajuste ao
problema \cite{klaus}. O pseudo-código do algoritmo VFSA \cite{stoffa} é apresentado abaixo:

Inicia com um valor aleatório para o parâmetro $m_0$ com uma energia $E(m_0)$

laço sobre a temperatura $T$

* laço sobre um incremento aleatório sobre a temperatura $T$

* * laço sobre parâmetros do modelo $i=1,...,NM$

* * * $u_i \in U[0,1]$

* * * $y_i=sgn(u_i-\frac{1}{2})T_i'[(1+T_i')^{2u_i-1}-1]$

* * * $m_{new}=m_{old}+y_i(m_{max}-m_{min})$

* * * $m_{min}<=m_{new}<=m_{max}$

* * fim do laço

* * agora temos um novo parâmetro $m_{new}$

* * $\Delta E=E(m_{new})-E(m_0)$

* * $P=exp(\frac{-\Delta E}{T})$

* *

* * Se $\Delta E <= 0$, faça

* * * $m_0=m_{new}$

* * * $E(m_0)=E(m_{new})$

* * fim

* * se $\Delta E > 0$, faça

* * * escreva um numero aleatório $r=U[0,1]$

* * * se $P > 0$, faça

* * * * $m_0=m_{new}$

* * * * $E(m_0)=E(m_{new})$

* * * fim

* * fim 

* fim do laço

fim do laço


\section{Função objeto: Semblance}
\label{sec:2.2}

O VFSA utiliza o semblance (coerência) como critério para determinar os parâmetros do SRC otimizados. Parte do princípio que
a coerência será máxima quando o ajuste entre as superfícies de tempo de trânsito modelada e a superfície de tempo de trânsito
aproximada será o melhor possível, nesse ponto há o mínimo global do erro relativo entre as duas superfícies.

O semblance é uma medida de coerência que se basei na soma de traços adjacentes, se os traços alinhados são similares
a soma dos traços adjacentes será máxima. A definição matemática de semblance de um grupo de $M$ traços, ao 
longo de uma janela de $N$ amostras, na posição $x_j$ no tempo $t_i$, é dada por \cite{seg}:

\begin{equation}
\label{eq:2.17}
 S_{NM}=\frac{ \sum_{i=1}^N [\sum_{j=1}^M x_j(t_i)]}{M \sum_{i=1}^N \sum_{j=1}^Mx^2_{j}}
\end{equation}

O semblance é a energia da soma dos valores dos traços dividida pela soma da energia dos traços \cite{seg}. 
Seu valor máximo é 1.
